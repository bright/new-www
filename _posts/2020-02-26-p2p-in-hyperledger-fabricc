---
layout: post
title: P2P in Hyperledger Fabric
author: tomek
hidden: true
tags: [blog blockchain hyperledger grpc]
---

Due to modular and plug-and-play architecture hyperledger fabric implements peer-to-peer protocol based on gRPC and proto buffers which allows bi-directional stream-based messaging. We will examine the individual elements of the protocol and examples of messages sent in the hyperlegder network.
gRPC
gRPC is alternative to REST and other RPC frameworks, based on HTTPS 2.0 which is faster and has improved security features over HTTPS 1.1. 
Like many RPC systems, gRPC is based around the idea of defining a service and specifying the methods that can be called remotely. In gRPC a client application can directly call methods on a server application on a different machine as if it was a local object, making it easier for you to create distributed applications and services.
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
On the server side, the server implements interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.
Due to fact that gRCP uses proto buffers, the server may be written in a different language than the client (for now it supports 10 programming languages). 
Proto buffers
Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serialising structured data.
To better understand how proto buffers works, let's compare it with JSON: 
{"name":"Peter","lastName":"Jason"}
This JSON object contains 35 characters, 25 of those including { : " " , } are informative and the actual message you send contains only 10 characters.
Let's now implement same message using proto buffers:
syntax = "proto3";
message Identity {
    string name = 1; 
    string lastName = 2;
}
This is our simple proto file in which we have defined Identity message, now let's generate js protobuf classes:
protoc --js_out=import_style=commonjs,binary:. identity.proto
This will provide simple accessors for each field (like name() and setName()) as well as methods to serialize/parse the whole structure to/from raw bytes.
// Serialization

var msg = new pb.Identity()
msg.setName("Peter")
msg.setLastname("Jason")
const bytes = msg.serializeBinary()
console.log(bytes)
After serialisation our 14 bytes long message in UInt8Array format might be become content of our gRPC request.
10 5 80 101 116 101 114 18 5 74 97 115 111 110
Usage in Hyperledger
Now, that we have basic knowledge of gRPC and proto buffers, we can examine how hyperledger distributes changes made in our chaincode asset.
Let's consider createCar function from fabcar chaincode:
async createCar(ctx, carNumber, make, model, color, owner) {
    console.info('============= START : Create Car ===========');

    const car = {
        color,
        docType: 'car',
        make,
        model,
        owner,
    }

    await ctx.stub.putState(carNumber,       Buffer.from(JSON.stringify(car)));
    console.info('============= END : Create Car ===========');
}
 At the end we call ctx.stub.putState function, let's take closer look how this function inserts new car asset into world state.
We are passing two arguments record key and Buffer which contains our car asset.

Inside function hyperledger uses putState proto buffer message with key, value and collection field.
// PutState is the payload of a ChaincodeMessage. It contains a key and value
// which needs to be written to the transaction's write set. If the collection is
// specified, the key and value would be written to the transaction's private
// write set.
message PutState {
   string key = 1;
   bytes value = 2;
   string collection = 3;
}
Next it generates js protobuf class, and sets our key and value as payload parameters, which is part of putState message. We can see that we also have to specify transactionId and channel that we are targeting.
async handlePutState(collection, key, value, channel_id, txId) {
    const payload = new _serviceProto.PutState();
    payload.setKey(key);
    payload.setValue(value);
    payload.setCollection(collection);

    const msg = {
        type: _serviceProto.ChaincodeMessage.Type.PUT_STATE,
        payload: payload.toBuffer(),
        txid: txId,
        channel_id: channel_id
    };

    return await this._askPeerAndListen(msg, 'PutState');
}
This message gets sent via GRPC request to defined peers in our connection profile, and we start listening for proposal responses!
