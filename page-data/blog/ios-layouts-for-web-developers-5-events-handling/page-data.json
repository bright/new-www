{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/ios-layouts-for-web-developers-5-events-handling","result":{"data":{"markdownRemark":{"html":"<p>Time to finish the <a href=\"/blog/ios-layouts-for-web-developers/\"><strong>iOS layouts for web developers</strong> series</a> with the post about events. Earlier in the series you might read about <a href=\"/blog/ios-layouts-for-web-developers-1-basic-building-blocks/\">the controls</a>, <a href=\"/blog/ios-layouts-for-web-developers-2-control-positioning/\">control positioning</a>, <a href=\"/blog/ios-layouts-for-web-developers-3-managing-appearance/\">managing the appearance</a> and <a href=\"/blog/ios-layouts-for-web-developers-4-css-properties-replacements/\">CSS properties replacements</a>.</p>\n<h2>Touchy state of the mobile touch events</h2>\n<p>Both in the web and in iOS we employ event-based models to define and control the interactions between our application and the external world, especially the user. The general idea of listening and reacting to particular events on specific parts of the UI or the whole application is the same on both environments. But the set of events is distinct and the main difference we need to always be aware is there are different ways to interact with the classical web than with the mobile device.</p>\n<p>The web's basic <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings\">DOM events model</a> was designed when touch interfaces were still very far from mainstream devices. It assumes the application is controlled by the mouse and the keyboard, thus the events carry the information like where the mouse pointer is or which key was pressed. And now, when we use the web on the mobile device, we’re still constrained to what type of interaction the browser supports and in a lot of cases we still need to talk in terms of clicks and mouse moves instead of gestures.</p>\n<p>The story about <a href=\"http://www.html5rocks.com/en/mobile/touch/\">proper touch events in the web</a> is <a href=\"http://www.w3.org/Mobile/mobile-web-app-state/#User_interactions\">long and convoluted</a>. First, Safari introduced own <a href=\"https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW22\">non-standard touch events support</a> back in iOS 2.0. The de-facto standard was adopted by few other mobile browsers and later codified as the <a href=\"http://www.w3.org/TR/touch-events/\">W3C standard</a>, but its adoption is <a href=\"http://caniuse.com/#feat=touch\">still quite poor</a>. Meanwhile the new, more generic alternative concept of <a href=\"http://www.w3.org/TR/pointerevents/\">Pointer Events</a> was coined, specified and <a href=\"http://caniuse.com/#feat=pointer\">introduced in Internet Explorer</a>. This led to the support fragmentation and uncertainty for developers what to rely on and what to expect in the future.</p>\n<p>On the other hand we have native mobile platforms like iOS that know much better how the contemporary device is controlled. Instead of mouse and keyboard events, the mobile platform is concerned about <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html\">multitouch gestures like panning or pinching or accelerometer-based motion recognition</a> and exposes it via the high-level gesture API instead of low-level information about each and every touch or finger movement.</p>\n<p>Of course, on a conceptual level, there are some analogies and some of the most common native gestures can be translated quite directly into web world - the example is a scroll gesture, done by tapping the screen and dragging the app’s content - mobile browsers happen to emit <code>scroll</code> events then.</p>\n<h2>Simplified gestures handling</h2>\n<p>Events in iOS are approached at multiple levels of abstraction, giving the developer the way to either easily use the system default gestures or alternatively dive down to more complex but more powerful API.</p>\n<p>The simpler layer available are <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2\">gesture recognizers</a>. Views can have multiple gesture recognizers attached, each configured to detect a particular, possibly complex gesture like pinching (<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPinchGestureRecognizer_Class/.html#//apple_ref/occ/cl/UIPinchGestureRecognizer\"><code>UIPinchGestureRecognizer</code></a>) or finger rotation (<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIRotateGestureRecognizer_Class/.html#//apple_ref/occ/cl/UIRotationGestureRecognizer\"><code>UIRotationGestureRecognizer</code></a>). When the gesture is detected, the recognizer calls its target - the callback we defined when setting the recognizer up:</p>\n<pre><code class=\"language-Objective-C\">- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UITapGestureRecognizer *doubleTapRecognizer = [[UITapGestureRecognizer alloc]\n        initWithTarget:self action:@selector(respondToDoubleTapGesture:)];\n    doubleTapRecognizer.numberOfTapsRequired = 2;\n    [self.view addGestureRecognizer:doubleTapRecognizer];\n}\n\n- (void)respondToDoubleTapGesture:(id)sender {\n    // react on double tap event here\n}\n</code></pre>\n<p>There’s no direct analogy available for complex gestures in the web world. Mobile browser apps often have their own handling for such a gestures, not even passing the raw gesture to the web app currently opened. For example, when pinching the website on the mobile device, it is zoomed in or out <a href=\"http://stackoverflow.com/questions/995914/catch-browsers-zoom-event-in-javascript\">without the web app being notified</a> about that event directly. The solution to handle complex gestures in mobile web is to defer to 3rd-party libraries that employ the low-level handling mechanisms to emulate the gesture events. Examples are <a href=\"http://hammerjs.github.io/\">Hammer.js</a> or <a href=\"https://github.com/hotstudio/touchy\">Touchy</a>.</p>\n<blockquote>\n<p>3rd-party libraries to handle complex events &#x3C;—> built-in gesture recognizers</p>\n</blockquote>\n<h2>Simple events simplified even more</h2>\n<p>For simpler events that do not require complex “recognizing” of movements pattern and consist just a single interaction, like tap, there is simplified mechanism available in iOS via <code>UIControl</code>'s <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class/.html#//apple_ref/occ/instm/UIControl/addTarget:action:forControlEvents:\"><code>addTarget:action:forControlEvents:</code></a> method, where we specify callbacks for particular events directly in the control:</p>\n<pre><code class=\"language-Objective-C\">- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    UIButton *button = // create or find a button\n    [button addTarget:self\n               action:@selector(respondToTapGesture:)\n     forControlEvents:UIControlEventTouchUpInside];\n}\n\n- (void)respondToTapGesture:(id)sender {\n    // react on tap event here\n}\n</code></pre>\n<p>The web analogy here is pretty clear - it’s like adding an event listener to the DOM element, either directly using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\"><code>element.addEventListener</code> API</a> or through convenient libraries like <a href=\"http://api.jquery.com/on/\">jQuery and its <code>on</code> function</a> etc.</p>\n<blockquote>\n<p><code>addEventListener</code> and its wrappers &#x3C;—> <code>addTarget:action:forControlEvents:</code></p>\n</blockquote>\n<p>What else we need to know here is the “translation table” from the DOM event to its <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class/.html#//apple_ref/doc/constant_group/Control_Events\">corresponding <code>UIControlEvent</code> type</a>. Of course the analogies are coarse-grained as always, but here we go:</p>\n<blockquote>\n<p><code>mousedown</code> event &#x3C;—> <code>UIControlEventTouchDown</code></p>\n</blockquote>\n<blockquote>\n<p><code>mouseup</code> event, conventionally also <code>click</code> event &#x3C;—> <code>UIControlEventTouchUpInside</code></p>\n</blockquote>\n<blockquote>\n<p><code>change</code> event on form controls &#x3C;—> <code>UIControlEventValueChanged</code></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop\">drag events</a> &#x3C;—> <code>UIControlEventTouchDragInside</code>, <code>UIControlEventTouchDragOutside</code>, <code>UIControlEventTouchDragEnter</code>, <code>UIControlEventTouchDragExit</code></p>\n</blockquote>\n<h2>Low-level events handling</h2>\n<p>There is also lower level touch event handling available within <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/doc/uid/TP40006783-CH4-SW13\"><code>UIResponder</code> base class</a>, which fortunately is a base class for <code>UIView</code> allowing these methods to be used everywhere. There are plenty of methods available to be overriden when our view implementation is interested in being notified about events like beginning of the touch (<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/occ/instm/UIResponder/touchesBegan:withEvent:\"><code>touchesBegan:withEvent:</code></a>), touch move (<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/occ/instm/UIResponder/touchesMoved:withEvent:\"><code>touchesMoved:withEvent:</code></a>) or touch end (<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/occ/instm/UIResponder/touchesEnded:withEvent:\"><code>touchesEnded:withEvent:</code></a>). These events consists of locations for all touch points, allowing multitouch support. But in order to detect any pattern, we need to analyse the data on our own. This resembles what we have <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\">available in some web browsers</a>.</p>\n<blockquote>\n<p>listening on <code>touchstart</code> event &#x3C;—> overriding <code>touchesBegan:withEvent:</code> method</p>\n</blockquote>\n<blockquote>\n<p>listening on <code>touchmove</code> event &#x3C;—> overriding <code>touchesMoved:withEvent:</code> method</p>\n</blockquote>\n<blockquote>\n<p>listening on <code>touchend</code> event &#x3C;—> overriding <code>touchesEnded:withEvent:</code> method</p>\n</blockquote>\n<blockquote>\n<p>listening on <code>touchcancel</code> event &#x3C;—> overriding <code>touchesCancelled:withEvent:</code> method</p>\n</blockquote>\n<p>Raw <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/doc/uid/TP40006783-CH4-SW19\">motion events</a> handling is also available within <code>UIResponder</code> in the same fashion as touch events, using <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/occ/instm/UIResponder/motionBegan:withEvent:\"><code>motionBegan:withEvent:</code></a> method and its siblings. In the web we might use <a href=\"http://mobiforge.com/design-development/html5-mobile-web-device-orientation-events\">device motion and orientation events</a> instead.</p>\n<blockquote>\n<p>listening on <code>devicemotion</code> event &#x3C;—> overriding <code>motionBegan:withEvent:</code> and <code>motionEnded:withEvent:</code> methods</p>\n</blockquote>\n<h2>Other events</h2>\n<p>For the sake of completeness, I’d mention few more event types that are somehow supported by both the web standard and iOS.</p>\n<blockquote>\n<p>listening on <code>window.onload</code>, jQuery <code>$(document).ready</code> or similar events &#x3C;—> overriding <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/viewDidLoad\"><code>UIViewController.viewDidLoad</code></a> method</p>\n</blockquote>\n<blockquote>\n<p>listening on <code>window.resize</code> event &#x3C;—> overriding <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITraitEnvironment_Ref/.html#//apple_ref/occ/intfm/UITraitEnvironment/traitCollectionDidChange:\"><code>traitCollectionDidChange:</code></a> method on the view or view controller</p>\n</blockquote>\n<blockquote>\n<p>listening on <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Detecting_device_orientation\"><code>deviceorientation</code></a> event &#x3C;—> adding observer to <code>NSNotificationCenter</code> that observes for <a href=\"http://thinkdiff.net/iphones/orientation-detection-at-runtime-in-ipad-or-iphone/\"><code>UIDeviceOrientationDidChangeNotification</code></a>; alternatively overriding <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITraitEnvironment_Ref/.html#//apple_ref/occ/intfm/UITraitEnvironment/traitCollectionDidChange:\"><code>traitCollectionDidChange:</code></a> method on the view or view controller</p>\n</blockquote>\n<blockquote>\n<p>set of proposed solutions for <a href=\"http://www.w3.org/Mobile/mobile-web-app-state/#Sensors_and_hardware_integration\">sensors and hardware integration</a>, not yet implemented &#x3C;—> <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/#//apple_ref/occ/instm/UIResponder/remoteControlReceivedWithEvent:\">remote control events on <code>UIResponder</code></a></p>\n</blockquote>\n<h2>Who handles the event?</h2>\n<p>Not only the types of events should be of our interest, but also which element/control is responsible for handling the event. We have some differences in that matter between the web and iOS.</p>\n<p>In the web, all the interaction events are first dispatched directly to the element that user interacted with, for example the <code>mousedown</code> event is first delivered to the innermost DOM element user clicked with her mouse. By default, all the listeners registered for that element are fired and the event is passed up the DOM hierarchy (this is called event bubbling). Every listener has the opportunity to stop the bubbling (<code>stopPropagation</code>) and/or cancel other listeners, but by default events traverse up to the top of the view hierarchy (to the <code>document</code> element), regardless if the event was somehow handled or not.</p>\n<p>In iOS, the way the event travels up the view hierarchy is similar - it is first delivered to the control down the tree and then passed up, but only until some control actually handles it - the traversal stops then.</p>\n<blockquote>\n<p>calling DOM event <code>stopPropagation</code> on event handling &#x3C;—> on iOS, propagation is stopped automatically when the event is handled</p>\n</blockquote>\n<p>Also, it is not fully accurate to say the events go up the view hierarchy. It actually go according to the <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW2\">responder chain</a>, which might or might not be equal to the view hierarchy order of controls. For touch events, unless we modify the <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIResponder_Class/.html#//apple_ref/occ/instm/UIResponder/nextResponder\"><code>nextResponder</code> property</a>, it is the same. But we might want to manage which control is the next responder on our own, for example to implement nice <a href=\"http://stackoverflow.com/questions/1347779/how-to-navigate-through-textfields-next-done-buttons\">keyboard traversal through the text inputs</a>.</p>\n<blockquote>\n<p>DOM events bubble up the DOM hierarchy &#x3C;—> iOS events traverse according to the responder chain</p>\n</blockquote>\n<p>But there are few more quirks. First one is the way the iOS determines which control was touched - it starts from the uppermost window view and <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4\">performs a hit-testing</a> on its subviews recursively. That takes into consideration only the views that are <a href=\"https://developer.apple.com/library/ios/qa/qa2013/qa1812.html\">actually visible within the view’s bounds</a> - so the views that are drawn outside its superview using <code>clipToBounds = NO</code> can’t handle the touch events properly. The workaround is to override <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/.html#//apple_ref/occ/instm/UIView/hitTest:withEvent:\">the hit-testing method</a>, but this gets hairy pretty quickly.</p>\n<blockquote>\n<p>DOM events are delivered to the innermost element according to view hierarchy only &#x3C;—> iOS touch events are delivered to the innermost control according both to view hierarchy and position within bounds</p>\n</blockquote>\n<p>One more important trick that is often used to modify the default touch target control on iOS is to disable the <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instp/UIView/userInteractionEnabled\"><code>userInteractionEnabled</code> flag</a> for the control to prevent it being considered for hit-testing. In that case, the control that gets the event might not actually be the innermost one, but the last of its ancestors that doesn’t have interaction disabled. To achieve something a bit similar in the web, we can set CSS <code>pointer-events: none</code> on the element we want to “disable\", although this is rather rough analogy.</p>\n<blockquote>\n<p><code>pointer-events: none</code> in CSS &#x3C;—> <code>UIView</code>’s <code>userInteractionEnabled</code> flag</p>\n</blockquote>\n<p>That’s all, folks. I hope anyone finds this series worth reading. I’d be grateful for any corrections, additions or just comments.</p>","excerpt":"Time to finish the iOS layouts for web developers series with the post about events. Earlier in the series you might read about the controls…","frontmatter":{"slug":null,"title":"iOS layouts for web developers #5 - events handling","description":null,"author":"adam","tags":["iOS"],"date":"2015-05-21T00:00:00.000Z","image":null},"timeToRead":11,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2015-05-21-ios-layouts-for-web-developers-5-events-handling.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2015-05-21-ios-layouts-for-web-developers-5-events-handling.md"}},"staticQueryHashes":["2189233960","3181594896"]}