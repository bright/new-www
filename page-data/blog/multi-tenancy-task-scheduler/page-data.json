{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/multi-tenancy-task-scheduler","result":{"data":{"markdownRemark":{"html":"<p><a href=\"%7B%25%20post_url%202017-12-12-spring-mvc-multi-tenacy%20%25%7D\">Last time I showed</a> how to extend Spring default request handler adapter so that we are able to schedule or reject incoming requests. The goal of the <code>TenantTaskCoordinator</code> is to:</p>\n<ul>\n<li>queue requests for processing </li>\n<li>limit the maximum number of concurrently processed requests</li>\n<li>reject requests after the maximum queue size is reached</li>\n<li>interrupt processing of a request upon an upstream subscription disposal</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9b1eab52e8a3cab78d44e66e86e6704d/c08c5/sorting.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAABsQlIWmJFP//EABoQAQADAAMAAAAAAAAAAAAAAAEAAgMREiH/2gAIAQEAAQUCtomndmfppXm4MzUr/8QAGREAAgMBAAAAAAAAAAAAAAAAAAIBETFB/9oACAEDAQE/AVeuE6f/xAAVEQEBAAAAAAAAAAAAAAAAAAABAP/aAAgBAgEBPwFIv//EAB0QAAICAQUAAAAAAAAAAAAAAAABESEQEjJRYYH/2gAIAQEABj8Canw3Msd9kanxj//EABsQAAMBAAMBAAAAAAAAAAAAAAERIQAxQWHB/9oACAEBAAE/IRMPmNghU9yNq8nNhjovMKoj8ZbJd3//2gAMAwEAAgADAAAAEJvv/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAwEBPxDR2PUl/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhQf/aAAgBAgEBPxB+MMv/xAAbEAEBAAMBAQEAAAAAAAAAAAABEQAhMUFh8P/aAAgBAQABPxBE1eLNAupcdZQ19foZT2amzXmN3w0qP3dcxIKPSqQIm8iI+mS5/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Assigning resources\"\n        title=\"Assigning resources\"\n        src=\"/static/9b1eab52e8a3cab78d44e66e86e6704d/1c72d/sorting.jpg\"\n        srcset=\"/static/9b1eab52e8a3cab78d44e66e86e6704d/a80bd/sorting.jpg 148w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/1c91a/sorting.jpg 295w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/1c72d/sorting.jpg 590w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/c08c5/sorting.jpg 640w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Tenant task coordinator execute method</h2>\n<p>Our entry point into <code>TenantTaskCoordinator</code> is a single method <code>fun &#x3C;T : Any> execute(job: Callable&#x3C;T>): Mono&#x3C;T></code>:</p>\n<pre><code class=\"language-kotlin\">    fun &#x3C;T : Any> execute(job: Callable&#x3C;T>): Mono&#x3C;T> {\n        return Mono.create({ outsideSink ->\n            val _workInProgressWasDecremented = AtomicBoolean(false)\n            fun decrementOnce() {\n                if (_workInProgressWasDecremented.compareAndSet(false, true)) {\n                    currentWorkInProgressCounter.decrementAndGet()\n                }\n            }\n\n            val workInProgress = currentWorkInProgressCounter.incrementAndGet()\n            if (workInProgress > maximumWorkInProgress) {\n                outsideSink.error(TooManyTasks(\"Work in progress $workInProgress exceeds $maximumWorkInProgress jobs in $name\"))\n                decrementOnce()\n            } else {\n                val singleJob = Mono.fromCallable(job).doAfterTerminate {\n                    decrementOnce()\n                }\n\n                val delayedTask = Task(name, singleJob as Mono&#x3C;Any>, outsideSink as MonoSink&#x3C;Any>)\n\n                outsideSink.onCancel {\n                    delayedTask.outsideCancel()\n                    decrementOnce()\n                }\n                \n                taskSink.next(delayedTask)\n            }\n        })\n    }\n</code></pre>\n<p>The first step is to return <code>Mono&#x3C;T></code> which is simply done with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-\"><code>Mono.create</code></a>. The <code>sink</code> we get passed is used to control the outcome observed from outside. It also allows for registering an <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/MonoSink.html#onCancel-reactor.core.Disposable-\"><code>onCancel</code></a> callback invoked when the upstream cancels its subscription. </p>\n<p>The <code>_workInProgressWasDecremented</code> is used to guard and decrement the <code>currentWorkInProgressCounter</code> in a thread safe fashion. We first check whether we have immediately exceeded the maximum number of queued jobs. If the threshold is reached, we notify the observer about the error with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/MonoSink.html#error-java.lang.Throwable-\"><code>outsideSink.error</code></a>. </p>\n<p>If we have enough capacity to a perform <code>job</code>, we convert it to a reactive world with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-\"><code>Mono.fromCallable</code></a> and attach a <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-\"><code>doAfterTerminate</code></a> callback that decrements the work in progress counter. The <code>Task</code> class links <code>singleJob</code> and <code>outsideSink</code> so that they are both accessible while processing. Finally, we schedule the <code>task</code> through <code>taskSink.next(delayedTask)</code>.</p>\n<h2>Task coordinator state</h2>\n<p>Let's have a look at the task coordinator state variables and how they are initialized:</p>\n<pre><code class=\"language-kotlin\">class TenantTaskCoordinator(private val scheduler: Scheduler,\n                            val maximumConcurrency: Int = 1,\n                            val maximumQueueSize: Int = 50,\n                            val name: String = \"\") : AutoCloseable {\n\n    private val maximumWorkInProgress = maximumQueueSize + maximumConcurrency\n\n    private val maxBufferSize = maximumWorkInProgress * 2\n\n    val currentWorkInProgressCounter = AtomicInteger()\n\n    private lateinit var taskSink: FluxSink&#x3C;Task>\n\n    private val taskSource = Flux.create&#x3C;Task>({ taskSink = it }, FluxSink.OverflowStrategy.BUFFER)\n\n    private val processSinkOnErrorResume = processSinkWithLimitedConcurrency()\n        .onErrorResume { error: Throwable? ->\n            LOG.warn(\"name={} Error processing sink with limited concurrency\", name, error)\n            processSinkWithLimitedConcurrency()\n        }\n</code></pre>\n<p>The first interesting part is how we setup <code>taskSink</code> by using <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-\"><code>Flux.create</code></a>. For clarity, we explicitly pass <code>FluxSink.OverflowStrategy.BUFFER</code> so that tasks are buffered in case they outpace the processor. The <code>name</code> is used to get better log messages. Finally, we call <code>processSinkWithLimitedConcurrency</code> to start task processing using the given <code>scheduler</code>. Interestingly the <code>onErrorResume</code> restarts the processing in case we have a bug.</p>\n<h2>Task coordinator concurrent processing</h2>\n<p>The most important and tricky to figure out part is to correctly process jobs. It took me several back and forth steps until I got the order of reactive API calls right. </p>\n<pre><code class=\"language-kotlin\">    private fun processSinkWithLimitedConcurrency(): Flux&#x3C;Any> {\n        return taskSource\n            .filter { !it.isCancelled }\n            .flatMap({ task ->\n                task.work\n                    .doOnError(task::onError)\n                    .doOnSuccess(task::onSuccess)\n                    .subscribeOn(scheduler)\n                    .timeout(task.outsideTimeout)\n                    .onErrorReturn(task)\n            }, maximumConcurrency, maxBufferSize)\n    }\n</code></pre>\n<p>First, we filter out tasks that are already cancelled. Then, we use <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-int-int-\"><code>flatMap</code></a> overload to process tasks with given maximum concurrency. The <code>flatMap</code> callback delegates most of the work to the mentioned <code>Task</code> instance. The <code>onErrorReturn</code> effectively suppresses any errors that might occur during <code>task</code> execution. Let's see how the inner <code>Task</code> class looks like:</p>\n<pre><code class=\"language-kotlin\">private data class Task(val name: String,\n                            private val job: Mono&#x3C;Any>,\n                            val outsideSink: MonoSink&#x3C;Any>,\n                            @field:Volatile var isCancelled: Boolean = false) {\n\n        val work: Mono&#x3C;Any> get() = if (isCancelled) Mono.empty() else job\n\n        lateinit var outsideTimeoutSink: MonoSink&#x3C;Task>\n        val outsideTimeout = Mono.create&#x3C;Task> { outsideTimeoutSink = it }\n\n        fun outsideCancel() {\n            isCancelled = true\n            outsideTimeoutSink.success(this)\n        }\n\n        fun onSuccess(result: Any?) {\n            outsideSink.success(result)\n        }\n        \n        fun onError(error: Throwable) {\n            LOG.warn(\"Task.onError {}\", this, error)\n            outsideSink.error(error)\n        }\n    }\n</code></pre>\n<p>The <code>job</code> argument is the <code>Callable</code> passed to the <code>execute</code> method. The <code>outsideTimeout</code> signals when the <code>task</code> instance subscription is cancelled. The signal is propagated inside <code>processSinkWithLimitedConcurrency</code> with a <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-org.reactivestreams.Publisher-\"><code>Mono.timeout</code></a> call and breaks the <code>task</code> processing. Last but not least the <code>onSuccess</code> and <code>onError</code> simply push the result or error to the <code>outsideSink</code> effectively notifying the observer of the result. </p>\n<p>The <a href=\"https://gist.github.com/miensol/1e2b203a128cdc428f3b0c598e515bd6\"><code>TenantTaskCoordinator</code></a> was not simple to figure out given the requirements mentioned at the begging of the post. I'm pleased with the final result although I must say it was not intuitive to figure out how to combine all the nuts and bolts of <a href=\"https://projectreactor.io/\">Reactor</a> library to achieve the desired outcome.</p>","excerpt":"Last time I showed how to extend Spring default request handler adapter so that we are able to schedule or reject incoming requests. Theâ€¦","frontmatter":{"slug":null,"title":"Multi tenancy task scheduler","description":null,"author":"piotr","tags":["spring","mvc","spring-boot","multi-tenant","reactive","reactor"],"date":"2018-01-03T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8d8d8","images":{"fallback":{"src":"/static/9b1eab52e8a3cab78d44e66e86e6704d/a962d/sorting.jpg","srcSet":"/static/9b1eab52e8a3cab78d44e66e86e6704d/da65b/sorting.jpg 160w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/f6fcd/sorting.jpg 320w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/a962d/sorting.jpg 640w","sizes":"(min-width: 640px) 640px, 100vw"},"sources":[{"srcSet":"/static/9b1eab52e8a3cab78d44e66e86e6704d/405d4/sorting.webp 160w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/dde70/sorting.webp 320w,\n/static/9b1eab52e8a3cab78d44e66e86e6704d/18e38/sorting.webp 640w","type":"image/webp","sizes":"(min-width: 640px) 640px, 100vw"}]},"width":640,"height":426}}}},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-04-multi-tenancy-task-scheduler.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-04-multi-tenancy-task-scheduler.md"}},"staticQueryHashes":["2189233960","3181594896"]}