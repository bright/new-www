{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/from-react-to-react-redux-in-a-few-steps","result":{"data":{"markdownRemark":{"html":"<p>In this post I'm going to focus on connecting <code>React</code> components with <code>Redux</code>. If you are just starting out with <code>React + Redux</code> or you have already worked with these before, but want to make this concept a bit clearer then feel invited to read this post till the end ;)</p>\n<p>If you would like to get a bit more understanding of the flow in Redux, you can take a look at my previous <a href=\"https://brightinventions.pl/blog/redux-how-do-i-understand-it/\">post about how I understand the Redux architecture</a>.</p>\n<h2>Before we introduce Redux</h2>\n<p>Before we dive into <code>Redux</code> let's take a look at simple <code>React</code> component. What does it look like?\nJust to make it a bit clearer - let's use TypeScript with interfaces to show what <code>props</code> (input data) do we expect in the component.</p>\n<pre><code class=\"language-jsx\">interface Props {\n    title: string\n    numbers: number[]\n}\n\ninterface State {}\n\nexport class SimpleComponent extends React.Component&#x3C;Props, State> {\n\n  render() {\n    return &#x3C;div>\n      &#x3C;h1>{this.props.title}&#x3C;/h1>\n      {this.props.numbers.map(number => &#x3C;p>{number}&#x3C;/p>)}\n    &#x3C;/div>\n  }\n}\n</code></pre>\n<p>This component takes two input parameters - <code>title</code> and <code>numbers</code>. If we want to display it in our application, we need to pass these manually. For example:</p>\n<pre><code class=\"language-jsx\">&#x3C;SimpleComponent title='Test' numbers={[1,2,3,4]}/>\n</code></pre>\n<h2>Introducing Redux</h2>\n<p>I guess that in every developer's life there comes a time when one wants to make something more complex for no reason, so let's introduce <code>Redux</code> to our example. (Disclaimer: it was a joke).</p>\n<p>Do we really need <code>Redux</code>? Let's take a look at an example of an app without <code>Redux</code> first.</p>\n<pre><code class=\"language-jsx\">interface Props {}\ninterface State {}\nexport class FatComponent extends React.Component&#x3C;Props, State> {\n    render() {\n        return &#x3C;div>\n            &#x3C;SimpleComponent title='Test' numbers={[1,2,3,4]}/>\n            &#x3C;SimpleComponent title='Test' numbers={[1,2,3,4]}/>\n            &#x3C;SimpleComponent title='Test' numbers={[1,2,3,4]}/>\n            &#x3C;SimpleComponent title='Test' numbers={[1,2,3,4]}/>\n        &#x3C;/div>\n    }\n}\n</code></pre>\n<p>The <code>FatComponent</code> displays 4 <code>SimpleComponents</code> with the same numbers.\nLet's imagine that we would like to share the same numbers across all of our <code>SimpleComponents</code>.\nA good way to do it would be to move this data to one place (a parent).\nIn this case our <code>FatComponent</code> is a good candidate for this.</p>\n<pre><code class=\"language-jsx\">interface Props {}\ninterface State {\n    numbers: number[]\n}\nexport class FatComponent extends React.Component&#x3C;Props, State> {\n\n    constructor(props) {\n        super(props)\n        this.state = { numbers: [1, 2, 3, 4] }\n    }\n\n    render() {\n        const { numbers } = this.state\n        return &#x3C;div>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n        &#x3C;/div>\n    }\n}\n</code></pre>\n<p>But what if our <code>FatComponent</code> does not have this data instantly and would need to download it?\nLet's use a <code>fetchNumbers</code> method in <code>componentDidMount</code>.</p>\n<pre><code class=\"language-jsx\">interface Props {}\ninterface State {\n    numbers: number[]\n}\nexport class FatComponent extends React.Component&#x3C;Props, State> {\n\n    constructor(props) {\n        super(props)\n        this.state = { numbers: [] } // initially we have an empty numbers array\n    }\n\n    // async await - https://javascript.info/async-await\n    async componentDidMount() {\n        const numbers = await fetchNumbers() // this is my imaginary function that will provide me with numbers\n        this.setState({ numbers })\n    }\n\n    render() {\n        const { numbers } = this.state\n        return &#x3C;div>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n        &#x3C;/div>\n    }\n}\n</code></pre>\n<p>Ok, so we have a component that knows how to fetch numbers and display them in <code>SimpleComponents</code>. Great!\nBut what if we want to reuse our <code>FatComponent</code> and present numbers from different source?\nWhat if we do not want to fetch the data everytime our component mounts? - After all we can fetch this data once and we can use it in future.\nWhat if we want to use a different initial array?\nIn order to do this we could add parameters to <code>FatComponent</code> and pass them from a parent that renders our <code>FatComponent</code>.</p>\n<pre><code class=\"language-jsx\">interface Props {\n    // we moved numbers from State to Props as our FatComponent will not control the source of the numbers\n    numbers: number[]\n    // this is a method that FatComponent will call when it decides that it wants to refresh its numbers\n    // we expect that if we call it, then FatComponent's parent will handle fetching the data and pass it to our component,\n    // that's why we use \"() => void\" type\n    refreshNumbers: () => void\n}\ninterface State {\n}\nexport class FatComponent extends React.Component&#x3C;Props, State> {\n\n    // async await is no longer needed here as we tell our parent to load data for us.\n    componentDidMount() {\n        this.props.refreshNumbers()\n    }\n\n    render() {\n        const { numbers } = this.props // we no longer have numbers in state - we need to change it to props\n        return &#x3C;div>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n            &#x3C;SimpleComponent title='Test' numbers={numbers}/>\n        &#x3C;/div>\n    }\n}\n\ninterface BigBossProps {}\ninterface BigBossState {\n    numbers: number[]\n}\nexport class BigBossParent extends React.Component&#x3C;BigBossProps, BigBossState> {\n\n    constructor(props) {\n        super(props)\n        this.state = { numbers: [] }\n    }\n\n    async onFetchNumbers() {\n        // if we fetched numbers before, then we won't do it again\n        const hasDataOrPendingRequest = // check pending request &#x26;&#x26; data existence\n        if (!hasDataOrPendingRequest) {\n            const numbers = await fetchNumbers() // this is my imaginary function that will provide me with numbers\n            this.setState({ numbers })\n        }\n    }\n\n    render() {\n        return &#x3C;FatComponent numbers={this.state.numbers} // we present numbers from BigBossParent's state in FatComponent\n            refreshNumbers={this.onFetchNumbers.bind(this)}/> // Bind with `this` in order to use BigBossParent component as `this` in `onFetchNumbers` method\n    }\n}\n</code></pre>\n<p>Now if render logic in our <code>BigBossParent</code> changes and it will conditionally render <code>FatComponent</code> we will run into a situation where <code>onFetchNumbers</code> will be called multiple times. The catch here is that our <code>BigBossParent</code> is pretty smart, so it won't download any new data but reuse the old array.\nBut then again. If at some point we decide to <code>unmount</code> <code>BigBossParent</code>, then we will lose the state that is kept there and we will have to fetch it once again.\nIf we want to avoid this, we could move the state to... You guessed it! Another parent.\nAnd this is where <code>Redux</code> comes with help to us. <code>Redux</code> provides us with a way to keep our application's state in one unified \"parent\" called <code>Store</code> that will provide it to the components that we render.\nWith <code>Redux</code> you will be able to:</p>\n<ul>\n<li>Keep your application state in one place - <code>Store</code></li>\n<li>Write tests for your application's state changes in an easier way as you can test it decoupled from the UI part.</li>\n<li>Use a unified way of changing this state (via <code>Actions</code> and <code>Reducers</code>), which comes in handy when the project grows and you need to move around it.</li>\n</ul>\n<p>Keep in mind that <code>Redux</code> is not a must and you do not need to use it for your application if you don't feel that you need it! - <a href=\"https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367\">You Might Not Need Redux</a>. But let's assume that we would like to introduce <code>Redux</code> to our example and keep numbers in this unified <code>Store</code>.\nThere are many approaches to how we can do it. The approach that is widely used and I personally like is connecting your main parent <code>components</code> with <code>Store</code> (in our case this would be <code>BigBossParent</code>) and then pass the required data to its children via their <code>props</code>. This way the rendered children are not aware of any <code>Redux</code> magic and if we decide to drop <code>Redux</code> at some point, then our all \"dumber\" (not connected to store) components would not require any changes.</p>\n<p>How would we approach connecting our <code>BigBossParent</code> to store (Place in <code>Redux</code> where data is kept)?\nFirst of all, we need to specify the input props of <code>BigBossParent</code> just as we did with <code>FatComponent</code>.\nJust as before, we move the things that we do not want to control to <code>BigBossProps</code> and we hope that a thing that renders this component will\ntake care of them and give it to use.</p>\n<pre><code class=\"language-jsx\">interface BigBossProps {\n    numbers: number[] // numbers will be provided to BigBossParent\n    refreshNumbers: () => void // BigBossProps will not fetch the data on its own (just as FatComponent)\n}\ninterface BigBossState {}\n// we do not export this method anymore\n// Please remember that we COULD do it and use this component as any other React component\nclass BigBossParent extends React.Component&#x3C;BigBossProps, BigBossState> {\n\n    render() {\n        // If FatComponent decides to refreshNumbers, our BigBossParent will pass this request to its parent.\n        return &#x3C;FatComponent numbers={this.props.numbers}\n            refreshNumbers={this.props.refreshNumbers()}/>\n    }\n}\n\nexport const connectedComponent = ... // we will get to this later\n</code></pre>\n<p>But what will be in charge of rendering our <code>BigBossParent</code>? We will render it in our applications \"root\" which will be connected to <code>Redux</code>.\nLet's imagine that this <code>div</code> here is the root of our app. The first thing that will be presented here is <code>Provider</code>.\nProvider, <code>createStore</code> is available through <code>react-redux</code> package and it will be responsible for providing components rendered inside it with a way\nto connect with the main application <code>store</code>. We will be able to get the state from it and apply changes to it (Let's focus on \"getting\" the state now).\nProvider will receive one parameter - a store which will be created with a <code>reducer</code> (let's not focus on them right now).</p>\n<pre><code class=\"language-html\">    &#x3C;div>\n        &#x3C;Provider store={createStore(reducer)}>\n            &#x3C;BigBossParent /> // Where are the props that we normally would pass here?\n            // Why don't we do it in as before?\n            // &#x3C;BigBossParent numbers={} refreshNumbers={}/>\n        &#x3C;/Provider>\n    &#x3C;/div>\n</code></pre>\n<p>Just before we move to our <code>BigBossParent</code> component, let's define an interface for our state in the application.\nWhat I mean is that every time that we get the state from the store (that we created with <code>createStore(reducers)</code>), we expect that it will be of <code>ApplicationState</code> type.</p>\n<pre><code class=\"language-js\">interface ApplicationState {\n    numbers: number[]\n}\n</code></pre>\n<p>Instead of passing the props to BigBossParent in a usual way, we will use the <code>connect</code> that is available from <code>react-redux</code> package.</p>\n<pre><code class=\"language-jsx\">interface BigBossProps {\n    numbers: number[] // numbers will be provided to BigBossParent\n    refreshNumbers: () => void // BigBossProps will not fetch the data on its own (just as FatComponent)\n}\ninterface BigBossState {}\n// we will not export the old component\nclass BigBossParent extends React.Component&#x3C;BigBossProps, BigBossState> {\n\n    render() {\n        // If FatComponent decides to refreshNumbers, our BigBossParent will pass this request to its parent.\n        return &#x3C;FatComponent numbers={this.props.numbers}\n            refreshNumbers={this.props.refreshNumbers()}/>\n    }\n}\n\n// This method will receive the application state in a first parameter\n// its job is to take the part of the application state that BigBossParent is interested in and return it\n// In this method we would like to exactly match the props that BigBossParent expects, however, we will not care about\n// methods. (We will not provide refreshNumbers method through mapStateToPros)\nfunction mapStateToProps(state: ApplicationState) {\n    // this method will return object has \"numbers\" with a value of numbers that are kept in our application state\n    return {\n        numbers: state.numbers\n    }\n}\n\n// This method will receive dispatch method as a first parameter\n// The dispatch will allow us to send actions to the store.\n// (if this concept is unfamiliar to you, please take a look at Redux documentation or my previous post - http://eliaszsawicki.com/story-of-redux/ )\nfunction mapDispatchToProps(dispatch: Redux.Dispatch) {\n    return {\n        refreshNumbers: () => dispatch({\n            type: 'UPDATE_NUMBERS',\n            payload: { numbers: [1, 2, 3, 4, 5]}\n        })\n    }\n}\n// instead we will export the component that is connected to our application store.\n// this means that the props that the BigBossParent component needed will be provided via our mapping functions\n// functions through mapDispatchToProps and variables through mapStateToProps\nexport const connectedComponent = connect(mapStateToProps, mapDispatchToProps)(BigBossParent)\n</code></pre>\n<p>Let's take a quick look at <code>Reducer</code>. Do you remember that we have passed it as our <code>createStore</code> parameter?\n<code>Reducer</code> is a function that takes in two parameters - <code>state</code> and <code>action</code> and returns a new <code>state</code>.</p>\n<pre><code class=\"language-js\">const DefaultState = { numbers: [] } // if we do not have a state yet (start of the app), we need to provide a default one\nfunction reducer(state: ApplicationState = DefaultState, action: Action): ApplicationState {\n    switch (action.type) {\n        case 'UPDATE_NUMBERS': // This is the action type that we sent from our BigBossParent component.\n            const newState = { numbers: action.payload.numbers }\n            return newState\n    }\n    return state\n}\n</code></pre>\n<p>In really simplified case we will have one reducer that handles our whole state, but in bigger apps we will have combined reducers that only take a part of the application state as a first parameter. The part that they know how to handle.\n<code>UPDATE_NUMBERS</code> is the action type that we sent from our BigBossParent component. Let's take a look at <code>mapDispatchToProps</code> once again:</p>\n<pre><code class=\"language-js\">//the dispatch parameter is in fact way to call `store.dispatch()`.\nfunction mapDispatchToProps(dispatch: Redux.Dispatch&#x3C;ApplicationState>) {\n    return {\n        refreshNumbers: () => dispatch({\n            type: 'UPDATE_NUMBERS',\n            payload: { numbers: [1, 2, 3, 4, 5]}\n        })\n    }\n}\n</code></pre>\n<p>What does this map do? At the time that we call <code>refreshNumbers</code> from <code>BigBossParent</code> component. What in fact happens is:</p>\n<pre><code class=\"language-js\">store.dispatch({\n            type: 'UPDATE_NUMBERS',\n            payload: { numbers: [1, 2, 3, 4, 5]}\n        })\n    }\n</code></pre>\n<p>This way we send an action to our store. Store receives the action and then passes both application state and this action to reducers (In our case this is a reducer mentioned above). It sees that the action type matches the one it handles - <code>UPDATE_NUMBERS</code> and creates\na new state accordingly. In our case it will apply the numbers sent as an action's payload. After it's done, the new state is returned and applied to the <code>store</code>.\nThis will now be the new state of our application. At the time that we receive this new state, our <code>BigBossParent</code> will be updated (mapping functions will be invoked again).</p>\n<p>And this is how you go from a <code>React</code> to <code>React-Redux</code> ;)\nIf you have any comments, please share them below!</p>\n<p><em>This article is cross-posted with <a href=\"https://eliaszsawicki.com/\">my personal blog</a>.</em></p>","excerpt":"In this post I'm going to focus on connecting React components with Redux. If you are just starting out with React + Redux or you haveâ€¦","frontmatter":{"slug":null,"title":"From React to React-Redux in a few steps","description":null,"author":"eliasz","tags":["React","Redux"],"date":"2018-02-08T23:00:00.000Z","image":null},"timeToRead":11,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-09-from-react-to-react-redux-in-a-few-steps.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-09-from-react-to-react-redux-in-a-few-steps.md"}},"staticQueryHashes":["2189233960","3181594896"]}